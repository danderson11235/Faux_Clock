#include <Bounce2.h>

/*
Name:    Sketch1.ino
Created:  10/13/2017 2:05:56 PM
Author: qwaszx
*/

//Main arduino code
/*
#include <Adafruit_LEDBackpack.h>
#include <Adafruit_GFX.h>
#include "Adafruit_LEDBackpack.h"
*/
//Adafruit_7segment fauxTimer = Adafruit_7segment();

#define DISPLAY_ADDRESS1 0 //---------------------!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#define SECOND 1000;


long previousMillis;
short state = 0;
long gameDurration = 100000;

char gameMode = 0;
bool gamesCompleated[3] = { true,true,false };

short gameSelectPins[3] = { 53,50,13 };//-----put your pins here----------------------------------
int gameConfirmPins[3] = { 52,51,12 };
Bounce bounceSelectPins[3];
Bounce bounceConfirmPins[3];
//---------------------------------Binary----------------------------
int targetNumber, currentNumber;
bool targetBinaryNumber[10] = {};
short buttonsPins[10] = { 2,3,4,5,6,7,8,9,10,11 };//--------------------------------------Put in your pins-----!!!!!
bool buttonsStates[10] = { false,false,false,false,false,false,false,false,false,false };
int BinaryledPins[10] = { 23,24,25,26,0,0,0,0,0,0 };//Pins!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Bounce bounceBinaryPins[10];// = Bounce();
							//-----------------------------------Simon-------------------------
const int MAX_LEVEL = 10;
int sequence[MAX_LEVEL];
int your_sequence[MAX_LEVEL];
int level = 1;
int velocity = 1000;
int simonPins[4] = { 0,0,0,0 };//--Pins!!!!!!!!!!!!!!!!!!!!!
Bounce bounceSimonPins[4];
int simonOutPins[4] = { 0,0,0,0 };//--Pins!!!!!!!!!!!!!!!!!!!!!

void setup() {
	Serial.begin(9600);
	//fauxTimer.begin(DISPLAY_ADDRESS1);
	delay(analogRead(A0));
	randomSeed(millis());
	targetNumber = random(0, 10);
	Serial.println(targetNumber);

	for (short i = 0; i < 10; i++)
	{
		targetBinaryNumber[i] = bitRead(targetNumber, i);
		Serial.print(targetBinaryNumber[i]);
	}
	for (int i = 0; i < 3; i++)
	{
		pinMode(gameSelectPins[i], INPUT_PULLUP);
		pinMode(gameConfirmPins[i], INPUT_PULLUP);
		bounceSelectPins[i].attach(gameSelectPins[i]);
		bounceSelectPins[i].interval(5);
		bounceConfirmPins[i].attach(gameConfirmPins[i]);
		bounceConfirmPins[i].interval(5);

	}
	for (int i = 0; i < 10; i++)
	{
		pinMode(buttonsPins[i], INPUT_PULLUP);
		bounceBinaryPins[i].attach(buttonsPins[i]);
		bounceBinaryPins[i].interval(5);
		pinMode(BinaryledPins[i], OUTPUT);
	}
	for (int i = 0; i < 4; i++)
	{
		pinMode(simonOutPins[i], OUTPUT);
		pinMode(simonPins[i], INPUT_PULLUP);
		bounceSimonPins[i].attach(simonPins[i]);
		bounceSimonPins[i].interval(5);
	}

}

void loop() {
	for (int i = 0; i<3; i++) {
		Serial.print(gamesCompleated[i]);
	}

	for (int i = 0; i < 3; i++) {
		bounceSelectPins[i].update();
	}

	if (millis() - previousMillis >= 1000) {
		if (upDateTimer(gameDurration)) state = 2;
	}

	if ((gamesCompleated[0] && gamesCompleated[1] && gamesCompleated[2]) == true) {
		state = 3;
	}

	if (level == 0) {
		generate_sequence();
		level = 1;
	}

	if (state == 0) {

		for (short i = 0; i < 3; i++)
		{
			if ((bounceSelectPins[i].fell() == true) && (!gamesCompleated[i]))
			{
				gameMode = i;
				state = 1;
				Serial.println("aaaaahhhhhhhhh");
				Serial.println(i);
			}
		}
	}

	if (state == 1) {
		if (gameMode == 0 && simon()) {
			gamesCompleated[0] = true;
			state = 0;
		}
		else if (gameMode == 1) {
			gamesCompleated[1] = true;
			state = 0;
		}
		else if (gameMode == 2 && binary()) {
			gamesCompleated[2] = true;
			state = 0;
		}
	}

	if (state == 2) { //game over
		gameOver();
	}

	if (state == 3) { //win
		win();
	}
}

bool upDateTimer(double upDateTimerIn) {//returns true when time runs out
	int countDown = (upDateTimerIn - millis()) / SECOND;
	//fauxTmer.print(countDown);
	Serial.println(countDown);
	if (countDown>0) {
		return false;
	}
	else {
		return true;
	}
}
//games
bool simon() {
		show_sequence();
		if (get_sequence()) {
			return true;
			state = 0;
		}
		return false;
}

bool resistor() {
	return true;
}

bool binary() {
	bool check = true;
	Serial.print(" ");
	Serial.print(targetNumber);
	Serial.print(" ");
	for (short i = 0; i < 10; i++)
	{
		bounceBinaryPins[i].update();
		if (bounceBinaryPins[i].fell() == true) {
			buttonsStates[i] = !buttonsStates[i];
		}
		Serial.print(" ");
		Serial.print(i);
		Serial.print(targetBinaryNumber[i]);
		Serial.print(buttonsStates[i]);
	}
	for (char i = 0; i < 4; i++)
	{
		digitalWrite(BinaryledPins[i], buttonsStates[i]);
	}
	bounceConfirmPins[2].update();
	if (bounceConfirmPins[2].fell() == true)
	{
		for (int i = 0; i < 10; i++)
		{
			if (buttonsStates[i] != targetBinaryNumber[i]) {
				check = false;
			}
		}

		if (!check)
		{
			gameDurration -= 5000;
			Serial.print("lose");
			return false;
			state = 0;
		}
		else
		{
			gameDurration += 10000;
			Serial.print("win");
			return true;
		}
	}
	else
	{
		return false;
	}
}

void show_sequence() {
	allOff();
	for (int i = 0; i < MAX_LEVEL; i++)
	{
		digitalWrite(simonOutPins[sequence[i]], HIGH);
		delay(velocity);
		digitalWrite(simonOutPins[sequence[i]], HIGH);
		if (millis() - previousMillis >= 1000) {
			if (upDateTimer(gameDurration)) {
				state = 2;
				return;
			}
		}
	}

}

bool get_sequence() {
	allOff();
	for (int i = 0; i < 4; i++)
	{
		bounceSimonPins[i].update();
	}
	bool flag = true;
	for (int j = 0; j < MAX_LEVEL; j++)
	{
		while (flag)
		{
			for (int i = 0; i < 4; i++)
			{
				if (bounceSimonPins[i].fell())
				{
					digitalWrite(simonOutPins[i], HIGH);
					your_sequence[j] = i;
					flag = false;
				}
			}
			if (millis() - previousMillis >= 1000) {
				if (upDateTimer(gameDurration)) {
					state = 2;
					return false;
				}
			}
		}
		if (your_sequence[j] != sequence[j])
		{
			wrong_sequence();
			return false;
		}
	}
	if (right_sequence()) {
		return true;
	}
	return false;
}

void generate_sequence() {
	randomSeed(millis());
	for (int i = 0; i < MAX_LEVEL; i++) {
		sequence[i] = random(0, 4);
	}
}

void wrong_sequence() {
	allOff();
	allOn();
	allOff();
	allOn();
	allOff();
	allOn();
	allOff();

	level = 0;
	velocity = 1000;
	gameDurration -= 10000;
}

bool right_sequence() {
	allOff();
	allOn();
	allOff();
	if (level < MAX_LEVEL)
	{
		level++;
		velocity -= (velocity / 6);
		return false;
	}
	else
	{
		return true;
	}
}

void gameOver() {
	Serial.println("Lose");
}

void win() {
	Serial.println("Win");
}

void allOff() {
	for (int i = 0; i < 4; i++)
	{
		digitalWrite(simonOutPins[i],LOW);
	}
}

void allOn() {
	for (int i = 0; i < 4; i++)
	{
		digitalWrite(simonOutPins[i], HIGH);
	}
}
